# A0122061B
###### parser\ActionLibrary.java
``` java

/**
 * This class stores all the possible actions that users can input to be
 * processed as a possible logic command.
 */
public class ActionLibrary {

    /*
     * ====================================================================
     * Attributes/Variables
     * ====================================================================
     */
    private static ActionLibrary theOne = null;
    private boolean isPreProcessed = false;
    private TreeMap<String, String> actionTree;

    /*
     * ====================================================================
     * Magic Constants
     * ====================================================================
     */
    private final String NOT_FOUND = "invalid input";

    private final String[] CREATE_LIST = { "create", "add", "`a", "`c", "create", "`n", "new", "plus", "`p" };

    private final String[] UNDO_LIST = { "undo", "undo", "`un" };

    private final String[] REDO_LIST = { "redo", "redo", "`re" };

    private final String[] UPDATE_LIST = { "update", "`ch", "change", "`e", "edit", "`u", "update" };

    private final String[] DELETE_LIST = { "delete", "bomb", "`b", "`del", "delete", "`rmv", "remove" };

    private final String[] SEARCH_LIST = { "search", "`s", "search", "`f", "find", "`dis", "display", "`rd",
					   "read", "`s", "show" };

    private final String[] SORT_LIST = { "sort", "sort", "`st", "`o", "order" };

    private final String[] SET_PATH_LIST = { "set", "set", "setPath", "`se" };

    private final String[] MARK_LIST = { "mark", "mark", "`m", "complete", "`cp", "done", "`dn", "finished",
					 "`fh" };

    private final String[] CLEAR_LIST = { "clear", "clear", "`clr", "reset", "`rst" };

    private final String[] EXIT_LIST = { "exit", "exit" };

    private final String[][] ACTION_ARRAY = { CREATE_LIST, REDO_LIST, UNDO_LIST, UPDATE_LIST, DELETE_LIST,
					      SEARCH_LIST, SORT_LIST, SET_PATH_LIST, MARK_LIST, CLEAR_LIST,
					      EXIT_LIST };

    
    /*
     * ====================================================================
     * Constructors
     * ====================================================================
     */

    private ActionLibrary() {
	
    }
    public static ActionLibrary getInstance() {
	System.out.println("library processed");
	if (theOne == null) {
	    theOne = new ActionLibrary();
	}
	return theOne;
    }
    /*
     * ====================================================================
     * Execute methods for ActionLibrary
     * ====================================================================
     */

    /**
     * If actionTree is not processed, adds the elements of ACTION_ARRAY into
     * it.
     * 
     * @return if ActionLibrary have been processed
     */
    private boolean preProcess() {
	if (!isPreProcessed) {
	    actionTree = new TreeMap<String, String>();
	    for (int i = 0; i < ACTION_ARRAY.length; i++) {
		String actionValue = ACTION_ARRAY[i][0];
		for (int j = 1; j < ACTION_ARRAY[i].length; j++) {
		    actionTree.put(ACTION_ARRAY[i][j], actionValue);
		}
	    }
	    isPreProcessed = true;
	}
	return isPreProcessed;
    }

    /**
     * Searches if input given matches an existing action command from the
     * library
     *
     * @param input
     *            the word to be tested with ActionLibrary
     * @return the compiled word for the action, if not found, return NOT_FOUND
     */

    protected String find(String input) {
	System.out.println("library entered");
	preProcess();
	String result = actionTree.get(input.toLowerCase());
	if (result == null) {
	    return NOT_FOUND;
	} else {
	    return result;
	}
    }
}
```
###### parser\BooleanChecker.java
``` java
public class BooleanChecker {

    /*
     * ====================================================================
     * Magic Constants
     * ====================================================================
     */
    private final String NOT_FOUND = "invalid input";
    private static BooleanChecker theOne = null;
    

    /*
     * ====================================================================
     * Constructors
     * ====================================================================
     */

    private BooleanChecker() {

    }
    
    public static BooleanChecker getInstance() {

	if (theOne == null) {
	    theOne = new BooleanChecker();
	}
	return theOne;
    }
    /*
     * ====================================================================
     * Methods
     * ====================================================================
     */
    public boolean isValidCommand(String command) {
	return !command.equalsIgnoreCase(NOT_FOUND);
    }

    public boolean isOneCommandFormat(String commandName) {
	return commandName.equalsIgnoreCase("undo") || commandName.equalsIgnoreCase("exit")
	       || commandName.equalsIgnoreCase("redo");
    }

    public boolean isSearchCommand(String commandName) {
	return commandName.equals("search");
    }

    public boolean isUpdateCommand(String commandName) {
	return commandName.equals("update");
    }

    public boolean isCreateCommand(String commandName) {
	return commandName.equals("create");
    }

    public boolean isClearAllCommand(String commandName, ArrayList<String> inputArr) {
	return commandName.equals("clear") && inputArr.size() == 0;
    }

    public boolean isArrayEmptyAndInvalid(ArrayList<String> inputArr) {
	return inputArr.size() == 0;
    }


    public boolean isDateUpdateSequence(CommandPackage inputData) {
	return inputData.getUpdateSequence().size() < 4;
    }

    public boolean isZero(int numberOfTime) {
	return numberOfTime == 0;
    }

    public boolean isTwo(int numberOfDates) {
	return numberOfDates == 2;
    }

    public boolean isOne(int numberOfTime) {
	return numberOfTime == 1;
    }

}
```
###### parser\CommandPackage.java
``` java

//This program is the output class from the parsing program for Daxuan to use to execute CRUD

public class CommandPackage {

    /*
     * ====================================================================
     * ATTRIBUTES
     * ====================================================================
     */
    private String command;
    private DatePackage dates;
    private String phrase;
    private String priority;
    private ArrayList<String> updateSequence;

    /*
     * ====================================================================
     * Constructors
     * ====================================================================
     */

    public CommandPackage() {
	command = "";
	phrase = "";
	dates = new DatePackage();
	priority = null;
	updateSequence = new ArrayList<String>();
    }

    public String setCommand(String cmd) {
	command = cmd;
	return command;
    }

    public String setPhrase(String text) {
	phrase = text;
	return phrase;
    }

    public DatePackage setDates(ArrayList<DateTime> time, String condition) {
	if (time == null) {
	    return null;
	}
	if (condition.equalsIgnoreCase("start")) {
	    dates.setDate(time.get(0), null);
	} else {
	    dates.setDate(null, time.get(0));
	}
	return dates;

    }

    public DatePackage setDates(ArrayList<DateTime> time) {
	if (time.get(0).compareTo(time.get(1)) < 0) {
	    dates.setDate(time.get(0), time.get(1));
	} else {
	    dates.setDate(time.get(1), time.get(0));
	}
	return dates;
    }

    public String setPriority(String priority) {
	this.priority = priority;
	return priority;
    }

    public ArrayList<String> addUpdateSequence(String sequence) {
	updateSequence.add(sequence);
	return updateSequence;

    }

    // Accessors
    public DatePackage getDate() {
	return dates;
    }

    public DateTime startingTime() {
	return dates.startingTime();
    }

    public DateTime endingTime() {
	return dates.endingTime();
    }

    public String getPhrase() {
	return phrase;
    }

    public String getCommand() {
	return command;
    }

    public String getPriority() {
	return priority;
    }

    public ArrayList<String> getUpdateSequence() {
	return updateSequence;
    }

}
```
###### parser\CommandParser.java
``` java

public class CommandParser {

    /*
     * ====================================================================
     * Attributes/Variables
     * ====================================================================
     */
    private static CommandParser theOne = null;

    public ArrayList<String> inputArr;
    public CommandPackage inputData;
    public String input;

    private ActionLibrary libraryForAction;
    private DateParser parserForDate;
    private TimeLibrary libraryForTime;
    private TimeParser parserForTime;
    private BooleanChecker checker;

    /*
     * ====================================================================
     * Magic Constants
     * ====================================================================
     */

    private final String NOT_FOUND = "invalid input";
    private final String START_TIME_LONG = "`startTime";
    private final String START_TIME_SHORT = "`st";
    private final String END_TIME_LONG = "`endTime";
    private final String END_TIME_SHORT = "`et";

    /*
     * ====================================================================
     * Constructors
     * ====================================================================
     */

    private CommandParser() {
	libraryForAction = ActionLibrary.getInstance();
	libraryForTime = TimeLibrary.getInstance();
	parserForTime = TimeParser.getInstance();
	checker = BooleanChecker.getInstance();
	parserForDate = DateParser.getInstance();

    }


    public static CommandParser getInstance() {

	if (theOne == null) {
	    theOne = new CommandParser();
	}
	return theOne;
    }

    /*
     * ====================================================================
     * Method for CommandParser
     * ====================================================================
     */

    /**
     * The main method that MainApp will call to parse the string given by users
     * and process the intructions that will be processed by Logic component.
     * 
     * @param command
     *            the set of words that users have typed into the command bar
     * @return a CommandPackage for Logic component to process
     */
    public CommandPackage getCommandPackage(String command) {
	input = command;
	 // try {
	    inputData = new CommandPackage();
	    String[] arr = input.split(" ");
	    arrToArrayList(arr);
	    String commandName = findAction();

	    inputData.setCommand(commandName);
	    System.out.println("name " + commandName);
	    System.out.println((!checker.isValidCommand(commandName)));
	    System.out.println();
	    if (!checker.isValidCommand(commandName)) {
		return null;
	    } else if (checker.isOneCommandFormat(commandName)
		       || checker.isClearAllCommand(commandName, inputArr)) {
		return inputData;
	    } else if (checker.isArrayEmptyAndInvalid(inputArr)) {
		return null;
	    } else if (checker.isUpdateCommand(commandName)) {
		return updateInput();
	    } else {
		String priority = findPriority();
		inputData.setPriority(priority);
	    }
	    if (checker.isCreateCommand(commandName)) {
		addDateTime();
		if (checker.isArrayEmptyAndInvalid(inputArr)) {
		    return null;
		}
	    }
	    if (checker.isSearchCommand(commandName)) {
		searchInput();
	    }
	    inputData.setPhrase(getPhrase());
	    return inputData;
/*-
	} catch (NullPointerException e1) {
	    System.out.println("NULL POINTER ERRORS");
	    return null;

	} catch (StringIndexOutOfBoundsException e2) {
	    System.out.println("StringIndexOutOfBoundsException");
	    return null;
	    
	}
	*/
	    
    }
    /*
     * ====================================================================
     * Parser For Add
     * ====================================================================
     */

    /**
     * The main method processes input with only 1 date input and 0 time input
     * and input into the CommandPackage
     * 
     * @param dateArr
     *            an array of existing date format
     * @param i
     *            the index that is going to process the dateArr element
     * @return the updated inputArr
     */
    private DatePackage addDateTime() {
	int numberOfDates = countDate();
	int numberOfTime = countTime();
	ArrayList<DateTime> dateArr;
	if (checker.isOne(numberOfDates)) {
	    dateArr = extractDate();
	    if (checker.isZero(numberOfTime)) {
		for (int i = 0; i < inputArr.size(); i++) {
		    dateProcess1(dateArr, i);
		} 
	    } else if (checker.isOne(numberOfTime)) {
		dateArr = extractTime(dateArr);
		for (int i = 0; i < inputArr.size(); i++) {
		    dateProcess2(dateArr, i);
		}
	    } else if (checker.isTwo(numberOfTime)) {
		dateArr.add(dateArr.get(0));
		dateArr = extractTime(dateArr);
		inputData.setDates(dateArr);
	    }

	} else {
	    if (checker.isOne(numberOfTime)) {
		dateArr = extractTime();
		for (int i = 0; i < inputArr.size(); i++) {
		    dateProcess2(dateArr, i);
		}
	    }
	    if (checker.isTwo(numberOfDates)) {
		dateArr = extractTwoDate();
		if (checker.isTwo(numberOfTime)) {
		    dateArr = extractTime(dateArr);
		}
		inputData.setDates(dateArr);
	    } else if (checker.isTwo(numberOfTime)) {
		ArrayList<DateTime> timeArr = extractTime();
		inputData.setDates(timeArr);

	    }

	}
	return inputData.getDate();
    }

    /**
     * The main method processes input with only 1 date input and 0 time input
     * and input into the CommandPackage
     * 
     * @param dateArr
     *            an array of existing date format
     * @param i
     *            the index that is going to process the dateArr element
     * @return the updated inputArr
     */
    private ArrayList<String> dateProcess1(ArrayList<DateTime> dateArr, int i) {
	if (libraryForTime.isStart(inputArr.get(i))) {
	    inputData.setDates(dateArr, "start");
	    inputArr.remove(i);
	} else if (libraryForTime.isEnd(inputArr.get(i))) {
	    inputData.setDates(dateArr, "end");
	    inputArr.remove(i);
	} else {
	    inputData.setDates(dateArr, "end");
	}
	return inputArr;
    }

    /**
     * The main method processes input with only 1 date input and 1 time input
     * and input into the CommandPackage
     * 
     * @param command
     *            the set of words that users have typed into the command bar
     * @param i
     *            the index that is going to process the dateArr element
     * @return the updated inputArr
     */
    private ArrayList<String> dateProcess2(ArrayList<DateTime> dateArr, int i) {
	if (libraryForTime.isStart(inputArr.get(i))) {
	    inputData.setDates(dateArr, "start");
	    inputArr.remove(i);
	} else if (libraryForTime.isEnd(inputArr.get(i))) {
	    inputData.setDates(dateArr, "end");
	    inputArr.remove(i);
	} else {
	    inputData.setDates(dateArr, "end");
	}
	return inputArr;
    }

    private ArrayList<DateTime> extractDate() {
	ArrayList<DateTime> dateArr = new ArrayList<DateTime>();
	ArrayList<Integer> index = new ArrayList<Integer>();
	String test;
	for (int i = 0; i < inputArr.size(); i++) {
	    test = inputArr.get(i);
	    if (test.contains("`")) {
		test = test.substring(1);
	    }
	    if (parserForDate.isDate(test)) {
		String date = test;

		index.add(i);
		if (i < inputArr.size() - 1) {

		}
		dateArr.add(parserForDate.setDate(date));
	    }
	}
	for (int i = index.size() - 1; 0 <= i; i--) {
	    int indexToRemove = index.get(i);
	    inputArr.remove(indexToRemove);
	}
	return dateArr;
    }

    private ArrayList<DateTime> extractTwoDate() {
	ArrayList<DateTime> dateArr = new ArrayList<DateTime>();
	ArrayList<Integer> index = new ArrayList<Integer>();
	String test;
	for (int i = 0; i < inputArr.size(); i++) {
	    test = inputArr.get(i);
	    if (test.contains("`")) {
		test = test.substring(1);
	    }
	    if (parserForDate.isDate(test)) {
		String date = test;
		if (i >= 0) {
		    if ((libraryForTime.isEnd(inputArr.get(i - 1))
			 || libraryForTime.isStart(inputArr.get(i - 1)))
			&& !(index.contains(i - 1))) {
			index.add(i - 1);
			System.out.println("before " + inputArr.get(i - 1));
		    }
		}
		System.out.println("date" + inputArr.get(i));
		index.add(i);

		if (i < inputArr.size() - 1) {
		    if ((libraryForTime.isEnd(inputArr.get(i + 1))
			 || libraryForTime.isStart(inputArr.get(i + 1)))
			&& !(index.contains(i + 1))) {
			index.add(i + 1);
			System.out.println("after " + inputArr.get(i + 1));
		    }
		}

		dateArr.add(parserForDate.setDate(date));
	    }
	}
	for (

	int i = index.size() - 1; 0 <= i; i--)

	{
	    int indexToRemove = index.get(i);
	    inputArr.remove(indexToRemove);
	}
	return dateArr;

    }

    private ArrayList<DateTime> extractTime(ArrayList<DateTime> dateArr) {
	int count = 0;
	ArrayList<DateTime> newDateArr = new ArrayList<DateTime>();
	ArrayList<Integer> index = new ArrayList<Integer>();
	String test;
	for (int i = 0; i < inputArr.size(); i++) {
	    test = inputArr.get(i);
	    if (test.contains("`")) {
		test = test.substring(1);
	    }
	    if (parserForTime.isTime(inputArr.get(i))) {

		DateTime oldDate = dateArr.get(count);
		index.add(i);
		DateTime newDate = parserForTime.setTime(oldDate, test);
		newDateArr.add(newDate);
		count++;
	    }
	}
	for (int i = index.size() - 1; 0 <= i; i--) {
	    int indexToRemove = index.get(0);
	    inputArr.remove(indexToRemove);
	}
	return newDateArr;
    }

    private ArrayList<DateTime> extractTime() {
	ArrayList<DateTime> dateArr = new ArrayList<DateTime>();
	ArrayList<Integer> index = new ArrayList<Integer>();
	String test;
	for (int i = 0; i < inputArr.size(); i++) {
	    test = inputArr.get(i);
	    if (test.contains("`")) {
		test = test.substring(1);
	    }
	    if (parserForTime.isTime(test)) {
		index.add(i);
		dateArr.add(parserForTime.setTime(null, test));
	    }
	}
	for (int i = index.size() - 1; 0 <= i; i--) {
	    int indexToRemove = index.get(0);
	    inputArr.remove(indexToRemove);
	}
	return dateArr;
    }

    /*
     * ====================================================================
     * Parser For Search
     * ====================================================================
     */
    private void searchInput() {
	String sample;
	for (int i = 0; i < inputArr.size(); i++) {
	    sample = inputArr.get(i);
	    if (parserForTime.isValidSearchFormat(sample) || parserForDate.isDate(sample)) {
		inputData.setDates(extractSearchDate());
	    }
	}
    }

    private ArrayList<DateTime> extractSearchDate() {
	String date;
	for (int i = 0; i < inputArr.size(); i++) {
	    if (parserForDate.isDate(inputArr.get(i))) {
		date = inputArr.remove(i);
		return parserForDate.searchDate(date);
	    } else if (parserForTime.isValidSearchFormat(inputArr.get(i))) {
		date = inputArr.remove(i);
		return parserForTime.searchTime(date);
	    }
	}
	return null; 
    }

    /*
     * ====================================================================
     * Parser For Update
     * ====================================================================
     */
    private CommandPackage updateInput() {
	String sequence = "";
	String word;
	int numberOfDates = countDate();
	int numberOfTime = countTime();
	System.out.println(numberOfTime);
	for (int i = 0; i < inputArr.size(); i++) {
	    word = inputArr.get(i);
	    if (word.startsWith("`")) {
		if (word.length() == 1) {
		    inputArr.set(i, word + inputArr.get(i + 1));
		} else {
		    inputData.addUpdateSequence(sequence);
		    sequence = "";
		    sequence = word.substring(1);
		    if (word.equalsIgnoreCase(START_TIME_LONG) || word.equalsIgnoreCase(START_TIME_SHORT)) {
			sequence = updateStartDateParsing(numberOfDates, numberOfTime, i);
		    } else {
			if (word.equalsIgnoreCase(END_TIME_LONG) || word.equalsIgnoreCase(END_TIME_SHORT)) {
			    sequence = updateEndDateParsing(numberOfDates, numberOfTime, i);
			}
		    }
		}
	    } else {
		sequence = sequence + " " + word;
	    }
	}
	inputData.addUpdateSequence(sequence);
	if (checker.isDateUpdateSequence(inputData)) {
	    inputData.addUpdateSequence(inputData.getDate().toString());
	}
	return inputData;
    }

    private String updateEndDateParsing(int numberOfDates, int numberOfTime, int i) {
	String sequence;
	ArrayList<DateTime> dateArr;
	sequence = "endTime";
	if (checker.isOne(numberOfDates)) {
	    dateArr = extractDate();
	    if (checker.isOne(numberOfTime)) {
		dateArr = extractTime(dateArr);
	    }
	} else if (checker.isOne(numberOfTime)) {
	    dateArr = extractTime();
	} else if (inputArr.get(i + 1).equals("`delete") || inputArr.get(i + 1).equals("`remove")) {
	    System.out.println("deleteing");
	    dateArr = null;
	    inputData.addUpdateSequence(sequence);
	    inputData.addUpdateSequence("delete");
	} else {
	    dateArr = null;
	}
	inputData.setDates(dateArr, "end");
	return sequence;
    }

    private String updateStartDateParsing(int numberOfDates, int numberOfTime, int i) {
	String sequence;
	ArrayList<DateTime> dateArr;
	sequence = "startTime";
	if (checker.isOne(numberOfDates)) {
	    dateArr = extractDate();
	    if (checker.isOne(numberOfTime)) {
		dateArr = extractTime(dateArr);
	    }
	} else if (checker.isOne(numberOfTime)) {
	    System.out.println("extracing start time");
	    dateArr = extractTime();
	} else if (inputArr.get(i + 1).equals("`delete") || inputArr.get(i + 1).equals("`remove")) {
	    System.out.println("deleteing");
	    dateArr = null;
	    inputData.addUpdateSequence(sequence);
	    inputData.addUpdateSequence("delete");
	} else {
	    dateArr = null;
	}
	inputData.setDates(dateArr, "start");
	return sequence;
    }

    /*
     * ====================================================================
     * inputArr manipulators
     * ====================================================================
     */

    public ArrayList<String> arrToArrayList(String[] arr) {
	inputArr = new ArrayList<String>();
	for (int i = 0; i < arr.length; i++) {
	    inputArr.add(arr[i]);
	}
	return inputArr;
    }

    private int countDate() {
	System.out.println("counting");
	int count = 0;
	for (int i = 0; i < inputArr.size(); i++) {
	    System.out.println("checking " + inputArr.get(i));
	    if (parserForDate.isDate(inputArr.get(i)) || parserForDate.isDate(inputArr.get(i).substring(1))) {
		count++;
	    }
	}
	return count;
    }

    private int countTime() {
	int count = 0;
	for (int i = 0; i < inputArr.size(); i++) {
	    if (parserForTime.isTime(inputArr.get(i)) || parserForTime.isTime(inputArr.get(i).substring(1))) {
		count++;
	    }
	}
	return count;
    }

    public String findAction() {
	String command;

	if (!callAction(inputArr.get(0)).equals(NOT_FOUND)) {
	    command = callAction(inputArr.get(0));
	    remove(inputArr.get(0));
	} else if (!callAction(inputArr.get(inputArr.size() - 1)).equals(NOT_FOUND)) {
	    command = callAction(inputArr.get(inputArr.size() - 1));
	    remove(inputArr.get(inputArr.size() - 1));
	} else {
	    command = NOT_FOUND;
	}
	return command;
    }

    public String findPriority() {
	String priority = "";
	String test;
	for (int i = 0; i < inputArr.size(); i++) {
	    test = inputArr.get(i);
	    if (test.startsWith("#")) {
		priority = test.substring(1);
		remove(test);
	    }
	}
	return priority;
    }

    private boolean remove(String word) {
	for (int i = 0; i < inputArr.size(); i++) {
	    if (inputArr.get(i).equalsIgnoreCase(word)) {
		remove(i);
	    }
	}
	return true;
    }
    
    public boolean remove(int index) {
	inputArr.remove(index);
	return true;
    }

    /*
     * ====================================================================
     * Boolean operations
     * ====================================================================
     */

    /*
     * ====================================================================
     * Accessors
     * ====================================================================
     */
    protected String getPhrase() {
	if (inputArr.isEmpty()) {
	    return "";
	} else {
	    String phrase = inputArr.get(0);
	    ;
	    for (int i = 1; i < inputArr.size(); i++) {
		phrase = phrase + " " + inputArr.get(i);
	    }
	    return phrase;
	}

    }



    public String callAction(String string) {
	String result;
	System.out.println("string");
	result = libraryForAction.find(string);
	return result;
    }

    public CommandPackage getInput() {
	return inputData;
    }
}
```
###### parser\DatePackage.java
``` java

public class DatePackage {
    /*
     * ====================================================================
     * ATTRIBUTES
     * ====================================================================
     */
    private DateTime start;
    boolean hasStartTime = false, hasStartMinute = false;
    boolean hasEndTime = false, hasEndMinute = false;
    boolean[] startTimeFormat = { hasStartTime, hasStartMinute };
    boolean[] endTimeFormat = { hasEndTime, hasEndMinute };
    private DateTime end;

    /*
     * ====================================================================
     * Constructors
     * ====================================================================
     */
    public DatePackage() {
	start = null;
	end = null;
    }

    /**
     * sets the day to the first attribute
     *
     * @param front
     *            a DateTime to be added as a start.
     * @return the actual date with the time of the task
     */
    public DateTime setDate(DateTime front) {
	start = front;
	end = null;
	return start;
    }

    protected DateTime setDate(DateTime front, DateTime back) {
	start = front;
	end = back;
	return end;
    }

    protected int setTimeFormat(boolean[] startFmt) {
	startTimeFormat = startFmt;
	return startFmt.length;
    }

    protected int setTimeFormat(boolean[] startFmt, boolean[] endFmt) {
	startTimeFormat = startFmt;
	endTimeFormat = endFmt;
	return endFmt.length;
    }

    /*
     * ====================================================================
     * Accessors
     * ====================================================================
     */
    public DateTime startingTime() {
	return start;
    }

    public DateTime endingTime() {
	return end;
    }

    public DateTime getDeadline() {
	return end;
    }

    public String toString() {
	return "Start : " + start + " End : " + end;
    }

}
```
###### parser\DateParser.java
``` java

/**
 * This class stores all the possible date formats that users can input to be
 * used
 */

public class DateParser {

    /*
     * ====================================================================
     * Magic Constants
     * ====================================================================
     */
    
    private static DateParser theOne = null;
    // format -1 : invalid format
    private final int INVALID_FORMAT_TYPE = -1;

    // format 0 : full date, with year
    private final int FORMAT_TYPE_0 = 0;
    private final String DATE_FORMAT_0 = "dd/MM/YYYY";
    private final String DATE_FORMAT_1 = "dd-MM-YYYY";
    private final String DATE_FORMAT_2 = "dd.MM.YYYY";
    private final String DATE_FORMAT_3 = "dd/MMM/YYYY";
    private final String DATE_FORMAT_4 = "dd-MMM-YYYY";
    private final String DATE_FORMAT_5 = "dd.MMM.YYYY";

    // format 1 : with day and month only
    private final int FORMAT_TYPE_1 = 1;
    private final String DATE_FORMAT_6 = "dd/MM";
    private final String DATE_FORMAT_7 = "dd-MM";
    private final String DATE_FORMAT_8 = "dd/MMM";
    private final String DATE_FORMAT_9 = "dd-MMM";
    private final String DATE_FORMAT_10 = "dd.MMM";

    // format 2 : day of the week, Friday, etc.
    private final int FORMAT_TYPE_2 = 2;
    private final String DATE_FORMAT_11 = "E";

    // format 3 : just day, month, year mutually exclusively
    private final int FORMAT_TYPE_3 = 3;
    private final String DATE_FORMAT_12 = "dd/";
    private final String DATE_FORMAT_13 = "dd-";
    private final String DATE_FORMAT_14 = "dd.";
    private final String DATE_FORMAT_15 = "MMM";
    private final String DATE_FORMAT_16 = "/MM/";
    private final String DATE_FORMAT_17 = "-MM-";
    private final String DATE_FORMAT_18 = ".MM.";
    private final String DATE_FORMAT_19 = "YYYY";

    // format 4 : Referral days with respect to current date
    private final int FORMAT_TYPE_4 = 4;
    private final String DATE_TODAY = "today";
    private final String DATE_TOMORROW = "tomorrow";
    private final String DATE_TMRW = "tmrw";
    private final String DATE_TMR = "tmr";
    private final String DATE_YESTERDAY = "yesterday";

    // Indexes for ArrayList<DateTimeFormatter> dateFormats
    private final int FORMAT_TYPE_0_INDEX = 6;
    private final int FORMAT_TYPE_1_INDEX = 11;
    private final int FORMAT_TYPE_2_INDEX = 12;
    private final int FORMAT_TYPE_3_INDEX = 20;

    private final ArrayList<DateTimeFormatter> dateFormats =
	    new ArrayList<DateTimeFormatter>(Arrays.asList(DateTimeFormat.forPattern(DATE_FORMAT_0),
							   DateTimeFormat.forPattern(DATE_FORMAT_1),
							   DateTimeFormat.forPattern(DATE_FORMAT_2),
							   DateTimeFormat.forPattern(DATE_FORMAT_3),
							   DateTimeFormat.forPattern(DATE_FORMAT_4),
							   DateTimeFormat.forPattern(DATE_FORMAT_5),
							   DateTimeFormat.forPattern(DATE_FORMAT_6),
							   DateTimeFormat.forPattern(DATE_FORMAT_7),
							   DateTimeFormat.forPattern(DATE_FORMAT_8),
							   DateTimeFormat.forPattern(DATE_FORMAT_9),
							   DateTimeFormat.forPattern(DATE_FORMAT_10),
							   DateTimeFormat.forPattern(DATE_FORMAT_11),
							   DateTimeFormat.forPattern(DATE_FORMAT_12),
							   DateTimeFormat.forPattern(DATE_FORMAT_13),
							   DateTimeFormat.forPattern(DATE_FORMAT_14),
							   DateTimeFormat.forPattern(DATE_FORMAT_15),
							   DateTimeFormat.forPattern(DATE_FORMAT_15),
							   DateTimeFormat.forPattern(DATE_FORMAT_16),
							   DateTimeFormat.forPattern(DATE_FORMAT_17),
							   DateTimeFormat.forPattern(DATE_FORMAT_18),
							   DateTimeFormat.forPattern(DATE_FORMAT_19)));
    /*
     * ====================================================================
     * Constructors
     * ====================================================================
     */
    
    private DateParser() {
    }
    public static DateParser getInstance() {

	if (theOne == null) {
	    theOne = new DateParser();
	}
	return theOne;
    }

  
    /*
     * ====================================================================
     * Methods to execute DateParser
     * ====================================================================
     */

    /**
     * Sets the date to the one from the input, assuming if input is a valid
     * date format.
     * 
     * @param input
     *            the assumed string of valid date format
     * @return a DateTime object with the date to the input
     */
    protected DateTime setDate(String input) {
	int formatTypeNumber = getDateFormatType(input);
	DateTime date = new DateTime();

	if (formatTypeNumber == 0) {
	    date = parseDateFormat0(input);
	} else if (formatTypeNumber == FORMAT_TYPE_1) {
	    date = parseDateFormat1(input, date);
	} else if (formatTypeNumber == FORMAT_TYPE_2) {
	    date = parseDateFormat2(input, date);
	} else if (formatTypeNumber == FORMAT_TYPE_4) {
	    date = parseDateFormat4(input);
	}

	return date;
    }

    protected DateTime setDate() {
	return new DateTime();
    }

    /**
     * Get the date format type of the input.
     * 
     * @param input
     *            the time to be tested
     * @return the format of the input date with the following options
     *         returns 0 : contains day, month and year
     *         returns 1 : date contains day and month only
     *         returns 2 : date is written in english (Tuesday, wed etc)
     *         returns 3 : date is yesterday/today/tomorrow
     *         returns 4 : date is only specified
     *         returns -1 : invalid
     */
    protected int getDateFormatType(String input) {
	DateTime date;
	int i = 0;
	for (; i < dateFormats.size(); i++) {
	    try {
		date = dateFormats.get(i).parseDateTime(input);
		break;
	    } catch (IllegalArgumentException e) {
		continue;
	    }
	}

	if (i < FORMAT_TYPE_0_INDEX) {
	    return 0;
	} else if (i < FORMAT_TYPE_1_INDEX) {
	    return FORMAT_TYPE_1;
	} else if (i < FORMAT_TYPE_2_INDEX) {
	    return FORMAT_TYPE_2;
	} else if (i < FORMAT_TYPE_3_INDEX) {
	    return i;
	} else if (isFormat4(input)) {
	    return FORMAT_TYPE_4;
	}

	return INVALID_FORMAT_TYPE;
    }

    protected boolean isDate(String input) {
	int formatTypeNumber = getDateFormatType(input);
	assert (formatTypeNumber >= INVALID_FORMAT_TYPE
		&& (formatTypeNumber <= FORMAT_TYPE_4
		    || (FORMAT_TYPE_2_INDEX <= formatTypeNumber && formatTypeNumber < FORMAT_TYPE_3_INDEX)));

	if (formatTypeNumber == INVALID_FORMAT_TYPE) {
	    return false;
	} else {
	    return true;
	}
    }

    protected boolean isSameDate(DateTime date1, DateTime date2) {
	return (date1.getYear() == date2.getYear()) && (date1.getDayOfYear() == date2.getDayOfYear());
    }

    private DateTime parseDateFormat0(String input) {
	DateTime date = null;

	for (int i = 0; i < FORMAT_TYPE_0_INDEX; i++) {
	    try {
		date = dateFormats.get(i).parseDateTime(input);
	    } catch (IllegalArgumentException e) {
		continue;
	    }
	}

	return date;
    }

    private DateTime parseDateFormat1(String input, DateTime date) {
	int[] dateTokens = splitDayMonth(input);
	int targetDay = dateTokens[0];
	int targetMonth = dateTokens[1];
	int currentDay = date.getDayOfMonth();
	int currentMonth = date.getMonthOfYear();

	if (targetMonth < currentMonth || (targetMonth == currentMonth && targetDay < currentDay)) {
	    date = new DateTime(date.getYear() + 1, targetMonth, targetDay, 0, 0);
	} else {
	    date = new DateTime(date.getYear(), targetMonth, targetDay, 0, 0);
	}
	return date;
    }

    private DateTime parseDateFormat2(String input, DateTime date) {
	DateTime tempDate = dateFormats.get(FORMAT_TYPE_2_INDEX - 1).parseDateTime(input);
	int targetDayOfWeek = tempDate.getDayOfWeek();
	int currentDayOfWeek = date.getDayOfWeek();

	if (targetDayOfWeek < currentDayOfWeek) {
	    date = date.plusWeeks(1);
	}

	date = date.withDayOfWeek(targetDayOfWeek);
	return date;
    }

    private DateTime parseDateFormat4(String input) {
	DateTime today = new DateTime();

	if (input.equalsIgnoreCase(DATE_YESTERDAY)) {
	    return today.minusDays(1);
	} else if (input.equalsIgnoreCase(DATE_TOMORROW) || (input.equalsIgnoreCase(DATE_TMRW))
		   || (input.equalsIgnoreCase(DATE_TMR))) {
	    return today.plusDays(1);
	}

	return today;
    }

    private DateTime parseDateFormat5(String input, DateTime date) {
	int[] dateTokens = splitDayMonth(input);
	int targetDay = dateTokens[0];
	int currentDay = date.getDayOfMonth();
	int currentMonth = date.getMonthOfYear();

	if (targetDay < currentDay) {
	    date = new DateTime(date.getYear(), currentMonth + 1, targetDay, 0, 0);
	} else {
	    date = new DateTime(date.getYear(), currentMonth, targetDay, 0, 0);
	}
	return date;
    }

    private DateTime parseDateFormat6(String input, DateTime date) {
	int[] dateTokens = splitDayMonth(input);
	int targetMonth = dateTokens[0];
	int currentMonth = date.getMonthOfYear();

	if (targetMonth < currentMonth) {
	    date = new DateTime(date.getYear() + 1, targetMonth, 0, 0, 0);
	} else {
	    date = new DateTime(date.getYear(), targetMonth, 0, 0, 0);
	}
	return date;
    }

    private DateTime parseDateFormat7(String input, DateTime date) {
	int year = Integer.parseInt(input);
	date = new DateTime(year, 0, 0, 0, 0);
	return date;
    }

    private int[] splitDayMonth(String date) {
	String[] tokens = new String[2];
	if (date.contains("/")) {
	    tokens = date.split("/");
	} else if (date.contains("-")) {
	    tokens = date.split("-");
	}

	// System.out.println(tokens.length);
	int[] intTokens = new int[tokens.length];
	for (int i = 0; i < tokens.length; i++) {
	    try {
		intTokens[i] = Integer.parseInt(tokens[i]);
	    } catch (NumberFormatException e) {
		DateTime tempDate = DateTimeFormat.forPattern("MMM").parseDateTime(tokens[i]);
		intTokens[i] = tempDate.getMonthOfYear();
	    }
	}

	return intTokens;
    }

    protected ArrayList<DateTime> searchDate(String input) {
	ArrayList<DateTime> searchArea = new ArrayList<DateTime>();
	int formatTypeNumber = getDateFormatType(input);
	DateTime date = new DateTime();
	if (formatTypeNumber == 0 || formatTypeNumber == 1 || formatTypeNumber == 2
	    || formatTypeNumber == 4) {
	    if (formatTypeNumber == 0) {
		date = parseDateFormat0(input);
	    } else if (formatTypeNumber == 1) {
		date = parseDateFormat1(input, date);
	    } else if (formatTypeNumber == 2) {
		date = parseDateFormat2(input, date);
	    } else if (formatTypeNumber == 4) {
		date = parseDateFormat4(input);
	    }

	    searchArea.add(date.withTime(0, 0, 0, 0));
	    searchArea.add(date.withTime(23, 59, 59, 999));
	} else {
	    if (formatTypeNumber < 15) { // only date given
		date = parseDateFormat5(input, date);
		searchArea.add(date.withTime(0, 0, 0, 0));
		searchArea.add(date.withTime(23, 59, 59, 999));
	    } else if (formatTypeNumber < 19) {// only month is given
		date = parseDateFormat6(input, date);
		searchArea.add(date);
		searchArea.add(date.plusMonths(1).plusMillis(-1));
	    } else if (formatTypeNumber == 19) {
		date = parseDateFormat7(input, date);
		searchArea.add(date);
		searchArea.add(date.plusYears(1).plusMillis(-1));
	    }
	}
	return searchArea;
    }

    private boolean isFormat4(String input) {
	return input.equalsIgnoreCase(DATE_TODAY) || input.equalsIgnoreCase(DATE_TOMORROW)
	       || input.equalsIgnoreCase(DATE_YESTERDAY) || input.equalsIgnoreCase(DATE_TMRW)
	       || input.equalsIgnoreCase(DATE_TMR);
    }

}
```
###### parser\TimeLibrary.java
``` java

/**
 * This class stores all the refering time that users can input to be processed
 * as a start of end.
 */
public class TimeLibrary {

    /*
     * ====================================================================
     * Magic Constants
     * ====================================================================
     */
    private final String START_TERM_0 = "start";
    private final String START_TERM_1 = "from";
    private final String START_TERM_2 = "begin";
    private final String START_TERM_3 = "starts";
    private final String START_TERM_4 = "begins";

    private final String END_TERM_0 = "by";
    private final String END_TERM_1 = "to";
    private final String END_TERM_2 = "until";
    private final String END_TERM_3 = "ends";
    private final String END_TERM_4 = "end";
    private final String END_TERM_5 = "til";

    private ArrayList<String> startList = new ArrayList<String>(
	    Arrays.asList(START_TERM_0, START_TERM_1, START_TERM_2, START_TERM_3, START_TERM_4));

    private ArrayList<String> endList = new ArrayList<String>(
	    Arrays.asList(END_TERM_0, END_TERM_1, END_TERM_2, END_TERM_3, END_TERM_4, END_TERM_5));
   
    private static TimeLibrary theOne = null;
    

    /*
     * ====================================================================
     * Constructors
     * ====================================================================
     */

    private TimeLibrary() {

    }
    
    protected static TimeLibrary getInstance() {

	if (theOne == null) {
	    theOne = new TimeLibrary();
	}
	return theOne;
    }
    /*
     * ====================================================================
     * Execute methods for TimeLibrary
     * ====================================================================
     */

    /**
     * Searches if input given matches a specified start referral
     * 
     * @param input
     *            the word to be tested with TimeLibrary
     * @return	a boolean if it matches a start referral
     */
    protected boolean isStart(String input) {
	return startList.contains(input.toLowerCase());
    }
    
    
    /**
     * Searches if input given matches a specified end referral
     * 
     * @param input
     *            the word to be tested with TimeLibrary
     * @return a boolean if it matches a end referral
     */
    protected boolean isEnd(String input) {
	return endList.contains(input.toLowerCase());
    }
}
```
###### parser\TimeParser.java
``` java

public class TimeParser {

    /*
     * ====================================================================
     * Magic Constants
     * 
     * Listed below are the formats for that accepts the dates.
     * Here are the legends for the mentioned formats (TIME_FORMAT_0 to
     * TIME_FORMAT_9.
     * 
     * <HH> = Hours in 24 hours format
     * <hh> = Hours in 12 hours format (aa will be use, mentioned below)
     * <mm> = Minutes of the day
     * <aa> = If clock format is in 12 hours, aa will indicate am or pm
     * 
     * The dates are seperated by < : >, < . > or nothing
     * ====================================================================
     */

    private final String TIME_FORMAT_0 = "HH:mm";
    private final String TIME_FORMAT_1 = "HH.mm";
    private final String TIME_FORMAT_2 = "HHmm";
    private final String TIME_FORMAT_3 = "hh:mmaa";
    private final String TIME_FORMAT_4 = "hh.mmaa";
    private final String TIME_FORMAT_5 = "hhmmaa";
    private final String TIME_FORMAT_6 = "hhaa";
    private final String TIME_FORMAT_7 = "haa";
    private final String TIME_FORMAT_8 = "HH:";
    private final String TIME_FORMAT_9 = "HH.";
    private final int FORMAT_SIZE = 10;

    private ArrayList<DateTimeFormatter> timeFormats =
	    new ArrayList<DateTimeFormatter>(Arrays.asList(DateTimeFormat.forPattern(TIME_FORMAT_0),
							   DateTimeFormat.forPattern(TIME_FORMAT_1),
							   DateTimeFormat.forPattern(TIME_FORMAT_2),
							   DateTimeFormat.forPattern(TIME_FORMAT_3),
							   DateTimeFormat.forPattern(TIME_FORMAT_4),
							   DateTimeFormat.forPattern(TIME_FORMAT_5),
							   DateTimeFormat.forPattern(TIME_FORMAT_6),
							   DateTimeFormat.forPattern(TIME_FORMAT_7),
							   DateTimeFormat.forPattern(TIME_FORMAT_8),
							   DateTimeFormat.forPattern(TIME_FORMAT_9)));
    private static TimeParser theOne = null;

    /*
     * ====================================================================
     * Constructors
     * ====================================================================
     */

    private TimeParser() {

    }

    protected static TimeParser getInstance() {

	if (theOne == null) {
	    theOne = new TimeParser();
	}
	return theOne;
    }
    /*
     * ====================================================================
     * Execute methods for TimeParser
     * ====================================================================
     */

    /**
     * Sets the hours and minutes of an existing date
     *
     * @param date
     *            An existing date with no specified timing (only date is
     *            specified)
     * @param input
     *            the string of hours and minute
     * @return the actual date with the time of the task
     */
    protected DateTime setTime(DateTime date, String input) {
	if (isValidFormat(input)) {
	    date = parseTimeFormat(date, input);
	    return date;
	} else {
	    return date;
	}
    }

    /**
     * Checks if the following word input is an accepted time format
     * 
     * @param input
     *            the string word to be tested
     * @return a boolean (true/false) if the tested input is a valid format
     */
    private boolean isValidFormat(String input) {
	DateTime date;
	int i = 0;
	for (; i < timeFormats.size(); i++) {
	    try {
		date = timeFormats.get(i).parseDateTime(input);
		break;
	    } catch (IllegalArgumentException e) {
		continue;
	    } catch (NullPointerException e) {
		continue;
	    }
	}

	if (i < FORMAT_SIZE) {
	    if (i == 2 && input.length() == 3) { // to bypass strings that is
						 // indicated as "123".
		return false;
	    }
	    return true;
	} else {
	    return false;
	}
    }

    /**
     * Checks if the following word input is an accepted search time format
     * (TIME_FORMAT_6 to TIME_FORMAT_9)
     * 
     * @param input
     *            the string word to be tested
     * @return a boolean (true/false) if the tested input is a valid format
     */
    protected boolean isValidSearchFormat(String input) {
	DateTime date;
	int i = 6;
	for (; i < timeFormats.size(); i++) {
	    try {
		date = timeFormats.get(i).parseDateTime(input);
		break;
	    } catch (IllegalArgumentException e) {
		continue;
	    } catch (NullPointerException e) {
		continue;
	    }
	}

	if (i < FORMAT_SIZE) {
	    return true;
	} else {
	    return false;
	}
    }

    /**
     * Checks if the following word input is an accepted search time format
     * (TIME_FORMAT_6 to TIME_FORMAT_9)
     * 
     * @param input
     *            the string word to be tested
     * @return the range of time for Logic Component to search
     */
    protected ArrayList<DateTime> searchTime(String input) {
	DateTime currentTime = new DateTime();
	DateTime time = new DateTime();
	;
	ArrayList<DateTime> searchArea = new ArrayList<DateTime>();
	;
	if (isValidSearchFormat(input)) {
	    for (int i = 6; i < FORMAT_SIZE; i++) {
		try {
		    time = timeFormats.get(i).parseDateTime(input);
		    System.out.println(time);
		} catch (IllegalArgumentException e) {
		    continue;
		}
	    }
	    time = new DateTime(time.getYear(),
				time.getMonthOfYear(),
				time.getDayOfMonth(),
				time.getHourOfDay(),
				0);

	    if (!currentTime.isBefore(time)) {
		time = time.plusDays(1);
	    }
	}
	searchArea.add(time);
	searchArea.add(time.plusHours(1).plusMillis(-1));
	return searchArea;
    }

    /**
     * A wrapper method for isValidFormat
     * 
     * @param input
     *            the string word to be tested
     * @return a boolean (true/false) if the tested input is a valid format
     */
    protected boolean isTime(String input) {
	return isValidFormat(input);
    }

    /**
     * Sets the hours and minutes of an existing date
     *
     * @param date
     *            An existing date with no specified timing (only date is
     *            specified)
     * @param input
     *            the string of hours and minute
     * @return the actual date with the time of the task
     */
    private DateTime parseTimeFormat(DateTime date, String input) {
	DateTime time = null;

	for (int i = 0; i < FORMAT_SIZE; i++) {
	    try {
		time = timeFormats.get(i).parseDateTime(input);
		System.out.println(time);
	    } catch (IllegalArgumentException e) {
		continue;
	    }
	}
	if (date == null) {
	    date = new DateTime();

	}
	time = new DateTime(date.getYear(),
			    date.getMonthOfYear(),
			    date.getDayOfMonth(),
			    time.getHourOfDay(),
			    time.getMinuteOfHour());
	if (date.isBefore(time)) {
	    return time;
	} else {
	    return time.plusDays(1);
	}
    }

}
```
